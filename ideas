// in nested object - if outer object is readonly, all children are readonly as well

type Point (
    x: Float32,
    y: Float32
)

# derive Eq for Point // compile time magic

static impl Point {

    fn new() -> Self{
        // GC managed
        GC::new(Self(x = 1.2, y = 2.4))
    }

    fn new() -> Self{
        // RC managed
        RC::new(Self(x = 1.2, y = 2.4))
    }

    fn new() -> Self {
        allocator::new(Self(x = 1.2, y = 2.4))
    }
}

readonly impl SomeTrait for Point{

}

impl Drop for Point{
    fn drop() {

    }
}

// can be applied on a readonly type
readonly trait PartialEq<Rhs> {
    fn eq(other: readonly Rhs) -> Bool
    fn ne(other: readonly Rhs) -> Bool
}

fn some_fn() -> { name: String } + to_string {

}

value type Count = usize

typealias Long = Int64

import println from { core::io }

if { } else { }

match some_var {
    2 => {
        println(2)
    }

    3 => {
        println(3)
    }

    otherwise => {

    }
}

for x in 0..10 { }

for x in array_of(1,2,3){

}

loop {

    break
}

array_of(1,2,3).map{val -> val * 2}

if some_var {
    true => ...
    false =>
}


describe('Array'){
    describe('index_of'){
            it('should return -1 when the value is not present') {
              expect(array_of(1, 2, 3).index_of(4)).to_be(-1);
            }
        }
    }
}


fn main(args: Array<String>) -> Int32 {
    log.info("Elodie says hi")
}



export function assert_true(value: Boolean, message: String? = 'default string') {
    if !value {
        assert_true(true)
        assert_true(false)
        assert_true(false, message = 'Some message')
    }
}

let x : Int16 = loop {
    if true{
        return 10;
    }
}

- Red? indicated optional value a function either returns the value or None - no need for Some


- enums as syntactic sugar as a union of types - think of every enum variant is an actual type

type Red(Number);
type Green(Number);
type Blue(Number);
type ColorChannel = Red | Green | Blue

enum ColorChannel{
    Red(Number),
    Green(Number),
    Blue(Number)
}

function returns_red_channel() -> Red?{
    return Red(123)
}

function returns_red_channel() -> ColorChannel::Red?{
    Red(123)
}

let c = returns_red_channel()

-- if function accepts more than 2 arguments -- no positional arguments only named


from '@dee/package' import {
    awesome,
    super_awesome,
    mega_awesome
}

type Point (
    x: Number,
    y: Number
)

implement Some_Type {

}
